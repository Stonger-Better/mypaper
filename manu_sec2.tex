%%%%%%%%%%%%%%%%%%%%%%% file template.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is a general template file for the LaTeX package SVJour3
% for Springer journals.          Springer Heidelberg 2010/09/16
%
% Copy it to a new file with a new name and use it as the basis
% for your article. Delete % signs as needed.
%
% This template includes a few options for different layouts and
% content for various journals. Please consult a previous issue of
% your journal as needed.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% First comes an example EPS file -- just ignore it and
% proceed on the \documentclass line
% your LaTeX will extract the file if required
\begin{filecontents*}{example.eps}
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 19 19 221 221
%%CreationDate: Mon Sep 29 1997
%%Creator: programmed by hand (JK)
%%EndComments
gsave
newpath
  20 20 moveto
  20 220 lineto
  220 220 lineto
  220 20 lineto
closepath
2 setlinewidth
gsave
  .4 setgray fill
grestore
stroke
grestore
\end{filecontents*}
%
\RequirePackage{fix-cm}
%
%\documentclass{svjour3}                     % onecolumn (standard format)
%\documentclass[smallcondensed]{svjour3}     % onecolumn (ditto)
\documentclass[smallextended]{svjour3}       % onecolumn (second format)
%\documentclass[twocolumn]{svjour3}          % twocolumn
%
\smartqed  % flush right qed marks, e.g. at end of proof
%
\usepackage{graphicx}
\usepackage{amssymb,amsmath}
\usepackage{array,tabularx,multirow}
\usepackage[linesnumbered,boxed]{algorithm2e}
%\usepackage{algorithm}
%\usepackage{algorithmic}
% \usepackage{mathptmx}      % use Times fonts if available on your TeX system
%
% insert here the call for the packages your document requires
%\usepackage{latexsym}
% etc.
%
% please place your own definitions here and don't use \def but
% \newcommand{}{}

%\newtheorem{lemma}{\bf{Lemma}}[section]

%\newtheorem{theorem}{\bf{Theorem}}[section]

%\newtheorem{definition}{Definition}[section]
% Insert the name of "your journal" with
% \journalname{myjournal}

\begin{document}

\title{A Preconditioning Algorithm for Large Linear Systems Based on A Low-stretch Spanning Tree% Based on a Low-stretch Spanning Tree  %\thanks{Grants or other notes
%about the article that should go on the front page should be
%placed here. General acknowledgments should be placed at the end of the article.}
%A practical preconditioning algorithm for Laplacian(SDD) linear system
}
%\subtitle{Do you have a subtitle?\\ If so, write it here}

%\titlerunning{Short form of title}        % if too long for running head

\author{Huirong Zhang \and  Jianwen Cao \and Xiaohui Liu  %etc.
}%\inst{1,2}

%\authorrunning{Short form of author list} % if too long for running head

\institute{H.R. Zhang \at
              State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences. \\
              \email{zhang06.happy@163.com}           %  \\
%%             \emph{Present address:} of F. Author  %  if needed
           \and
           J.W. Cao \at
             State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences.\\
           \and
           X.H. Liu  \at
              State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences.\\
}

%\institute{  State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences. \\
%              \email{zhang06.happy@163.com}           %  \\
%%             \emph{Present address:} of F. Author  %  if needed
%           \and
%             State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences.\\
%          }


\date{Received: date / Accepted: date}
% The correct dates will be entered by the editor


\maketitle

\begin{abstract}
In this paper, we present an efficient algorithm for preconditioning sparse, symmetric, diagonally-dominant(SDD) linear systems by using combinatorial preconditioning techniques.  Firstly, we build a low-stretch spanning tree of a graph associated with a linear system by using algorithm proposed by Alon et al. and  add appropriate high stretch edges to the tree straightly or add edges based on a tree-decomposition algorithm to get an optimized subgraph. Then, convert the subgraph into a SDD matrix and take it as a preconditioner. %solve a  SDD system $Ax=b$ preconditioned by a matrix converted from the subgraph we create.
Finally, we give an implementation and  performance analysis of our subgraph preconditioners. %We show experimentally that these combinatorial preconditioners  have robust convergence and  have good scalability.
We test the algorithm on extensive numerical experiments arising from both elliptic PDEs and  Laplacian systems of network graphs. Numerical experiments show that preconditioners constructed by our algorithm are more efficient than incomplete Choleskey factorization preconditioners and Vaidya's preconditioners. Moreover, our preconditioning algorithm is insensitive to the boundary condition and it scales well. %, which means our combinatorial preconditioning algorithm has good scalability.
%In addition, for the 2-D problems considered in this paper, preconditioners obtained based on a low stretch tree have better performance than  incomplete
%Cholesky preconditioners, which is sensitive to boundary  and anisotropy.
  Besides, the efficiency of our subgraphs preconditioners depends on not only the stretch  but also depends on the sparsity.  %But they are % and matrix size.


%\noindent {\bf AMS subject classifications: }
\keywords{preconditioning algorithm \and linear systems  \and low-stretch spanning tree \and tree-decomposition \and experimental analysis}
%\keywords{PCG Algorithm;  Augmented low stretch spanning tree; Tree-decomposition; SDD linear systems}
% \PACS{PACS code1 \and PACS code2 \and more}
% \subclass{MSC code1 \and MSC code2 \and more}
\end{abstract}

%Moreover, the smallest generalized eigenvalues of a linear system preconditioned by a subgraph preconditioner is 1, just as analyzed in theory.
%The experiments on network graphs show that  when a spanning tree of the underlying graph of a matrix has  low  average stretch, %or small max stretch at the same time,
%a preconditioner constructed based on such a spanning tree applied with a CG solver converges fast.


\section{Preliminaries.}\label{sec:1}
In this paper, we will focus on  preconditioning for  linear systems of the form $Ax=b$ where
 $A$ is a SDD matrix. %%%%%%%%%%%%%%%%%%%%下面的不知道咋改？？？
\begin{definition}
  (SDD)A  system $Ax = b$ is symmetric diagonally dominant(SDD) when A is symmetric and %symmetric matrix $A$ is positive semi-definite if $x^TAx\geq 0$ for all vectors $x\in \mathbb{R}^n$.
%A matrix $A$ is symmetric diagonally dominant(SDD) if
$|A_{i,i}|\geq \sum_{j\neq i}^{n}|A_{i,j}|$ for all $i=1,\cdots, n$.
\end{definition}

%We remark that a SDD matrix is
%positive semi-definite if and only if it is diagonally dominant and all of
%its diagonals are non-negative.


If the condition number of $A$ is large(eg. $A$ is a near-singular matrix), one often use a preconditioner $B$ to accelerate the CG iteration. A preconditioned linear
 system is in form of
 $$B^{-1}Ax=B^{-1}b\quad(\text{left preconditioning}).$$
 When $A,B$ is symmetric positive definite, the PCG converges to within a fixed tolerance in $O(\sqrt{\kappa_f(A,B)})$ iterations, where
 $$\kappa_f(A,B)=(max_{\scriptstyle x:Ax\neq 0}\frac{x^TAx}{x^TBx})(max_{\scriptstyle x:Ax\neq 0 }\frac{x^TBx}{x^TAx}),$$ %%%%%%%%%%%%%%%%%没改？？
 for symmetric $A$ and $B$ with \textbf{Span}$(A)=$\textbf{Span}($B$), $B$ is a preconditioner of $A$.


Laplacian matrices are symmetric matrices with non-negative diagonals and
non-positive off-diagonals such that $A_{i,i}=\sum_{j\neq i}|A_{i,j}|$ for all $i$.
In fact, linear systems in symmetric diagonally dominant
matrices can be reduced to Laplacian matrices. Firstly, as the support theory illustrated in \cite{BH}, if $\widetilde{A} = A+D$, where $A$ is a Laplacian, $D$ diagonal matrix with non-negative diagonals, $\kappa_f(\widetilde{A},B+D)\leq \kappa_f(A,B)$. Then, use Gremban's reduction \cite{Germban} to convert any SDD linear system into one with non-negative off diagonals.

 %Concretely, if $A$ is a symmetric diagonally dominant matrix, then decomposes $A$ into $D+A_n +A_p$, where $D$ is the diagonal of $A$, $A_n$ is the matrix containing all negative off-diagonal entries of $A$, and $A_p$ contains all the positive off-diagonals.Then consider the linear system
%
% \begin{equation*}
%  \left[
%   \begin{array}{cc}
%     D + A_n & -A_p \\
%     -A_p & D + A_n \\
%   \end{array}
% \right]
% \left[
% \begin{array}{c}
%    x_1\\
%    x_2
% \end{array}
%\right] =\left[\begin{array}{c}
%           b \\
%           -b
%         \end{array}\right].
% \end{equation*}
%and observes that $x = (x_1- x_2)/2 $ will be the solution to $Ax = b$, if a solution exists.
So, it suffices to consider constructing preconditioners for Laplacian matrices. %??????????????%添加什么？
 Our preconditioning algorithm is proposed by using the combinatorial property of Laplacian matrices. Now we introduce the isomorphism relation between Laplacian matrices and graphs.
Assuming $G=(V,E,\omega)$ is a connected undirected graph, $\omega$ is a mapping from edges to positive weights, $A$ is a Laplacian matrix, then
%For a weighted graph $G=(V,E,\omega)$, $\omega$ is a mapping from edges to positive weights, its Laplacian matrix can be defined as $$A_{i,j}= -\omega_{i,j} \hbox{ and } A_{i,i}=\sum_{j\neq i} \omega_{i,j}.$$
\begin{itemize} %每个非零非对角元对应一条边.
  \item $A \rightarrow G_A:$ each row of $A$ corresponds to a node of $G_A$ (namely $i$-th row corresponds to $i$),  the underlying graphs of $A$ can be defined as $G_A(V_A, E_A, \omega)$,  where $$V_A=\{1, 2, \cdots,  n\},  E_A=\{(i, j):i\neq j,  A_{ij}\neq 0\}$$.
  \item $G_A\rightarrow A:$  given graph $G_A= (V_A,  E_A,  \omega)$,  its Laplacian matrix is
$$A_{i, j}= -\omega_{i, j} \hbox{ and } A_{i, i}=\sum_{j:(j\neq i)} \omega_{i, j}.$$
\end{itemize}

%\subsection{Graphs and their Laplacian matrices}
If $A$ is the Laplacian of an unconnected graph,
the blocks corresponding to the connected components may
be solved independently. Henceforth, we assume the graphs are connected.

%Assume all weighted graphs in this paper have positive weights.
%There is a natural isomorphism between weighted
%graphs and Laplacian matrices: for a weighted graph $G=(V,E,\omega)$, $\omega$ is a mapping from edges to positive weights, its Laplacian matrix can be defined as $$A_{i,j}= -\omega_{i,j} \hbox{ and } A_{i,i}=\sum_{j\neq i} \omega_{i,j}.$$

%This isomorphism relation allow us to extend some algebraic operations to graphs. Concretely, if $G$ and $H$ are graphs and their Laplacian are $A$ and $B$ respectively, we will denote by $G + H $ the graph
%whose Laplacian is $A + B$, and by $\alpha G$ the graph whose Laplacian is $\alpha A$.
%Given a Laplacian matrix $A$, in order to construct a  preconditioner
%  Support graph preconditioning  technique is to construct preconditioners by build subgraph of

%Our preconditioning algorithm is based on a low stretch spanning tree.
For a given SDD matrix $A$, denote the underlying graph of it by $G_A$.
Our goal is to construct a preconditioner $B$ for $A$ by building a subgraph of $G_A$, while the preconditioning quality is measured in term of  \emph{stretch}.  Now we give the concept of stretch.

%Boman and Hendrickson \cite{BH01} recognized that for the purpose of preconditioning, one should measure the stretch of a spanning tree.

\begin{definition}%\label{stretch}
\textbf{(stretch)}
Given Laplacian matrices $A$ and
$B$, choose a mapping  of the edges in the graph $G_A$ onto paths in $G_B$. For each
$e =(i_1,i_2)\in E(G_A)$, let $path(e)=P(i_1,i_2)$ denote the corresponding path in $G_B$. Then
the  stretch of an edge $e$ in $G_A$ is
\begin{equation}\label{stretch}
stretch(i_1,i_2) = \sum_{\scriptstyle (j_1,j_2)\in P(i_1,i_2)}\frac{A_{i_1,i_2}}{B_{j_1,j_2}}.
\end{equation}
if $F$ is a subset edges on $V$, then stretch of $F$ is $$stretch(F)=\sum_{(i_1,i_2)\in F}stretch(i_1,i_2).$$
\end{definition}

Let $G =(V,E,\omega)$ be a connected graph,  $T=(V,F,\omega)$ be a spanning tree of $G$, where $F$ is a subset of $E$ having exactly $n-1$ edges, and the edges that
appear in $T$  have the same weight as they do in $G$. %As $T$ is a tree, every pair of vertices of $V$ is connected by a unique path in $T$. According to the isomorphism relationship between graphs and Laplacian matrices we know,
 For any edge $e\in G$, if $e_1,\cdots e_k\in F$ are the edges on the the unique path in $T$ connecting the endpoints of $e$, the stretch of $e$ with respect to $T$ is $$stretch(e)=\omega(e)(\sum_{i=1}^k 1/\omega(e_i)).$$
 %Before finding the low-stretch tree, we need to assign a positive length for each edge to be $\ell(e)=1/\omega(e)$. Then define the distance in $T$ between a pair of vertices $u,v\in V$ to be the sum of lengths of the edges on the unique path in $T$ between $u$ and $v$. %In the algorithm implementation, we need a preprocessing code to convert matrix to graph with assigned length as above rule.

Later, we will prove that a low stretch tree implies good preconditioning quality.


%\subsection{Our work}
%The key contribution of our work is an extension of Vaidya's techniques for constructing and analyzing combinatorial preconditioners. In this paper, we propose a simple combinatorial preconditioning algorithm based on a low stretch tree. We give two schemes for adding edges to the tree to construct a support subgraph. One scheme is to add edges with highest stretch  to the tree straightly. Another scheme is to
% take advantage of the tree-decomposition algorithm introduced in \cite{BHT} and to add off-tree edges which have highest stretch between the subtrees get from the decomposition. With both two schemes  one can get a stretch optimized subgraph according to the support theory. However, the numerical experiments show the latter scheme is much better than the first scheme.
%We implement the  algorithm for building a low stretch spanning tree constructed by Alon,Karp, Peleg, and West \cite{AKPW}. Then compute stretch for all the edges and construct the stretch optimized subgraphs based on the tree-decomposition algorithm or adding appropriate  high stretch edges straightly. Then we test our combinatorial preconditioners to preconditioning matrices arise from finite-differences discretizations of elliptic PDEs on regular meshes. We consider isotropic problems and anisotropic problems on regular 2-dimensional meshes.
%We compare the performance of our preconditioners based on a low stretch tree to that of the  Vaidya's preconditoners based on a maximum spanning tree and the drop-tolerance incomplete-Cholesky preconditioners (IC) by the use of a conjugate gradients iterative solver. All  of the tested matrices are generated by the software TAUCS.
%Finally, we give an experimental analysis to describe the  performance of our combinatorial preconditioners. The experiments show that our combinatorial preconditioners  have robust convergence.
%They are insensitive to the numerics of the problem. Their performance does not vary much when we change the boundary conditions of the isotropic problems or when we change the direction of anisotropy in anisotropic problems.
%
%Moreover, our combinatorial preconditioning algorithm has good scalability.
%
%
%
%
%
%\subsection{Paper Organization}
%
%Section \ref{sec:2} provides the analysis of combinational preconditioning in theory.  Section \ref{sec:3} presents our combinatorial preconditioning algorithm. Section \ref{sec:4} gives the numerical experiments. Section \ref{sec:5} gives some conclusions and directions for further research.



\end{document}
% end of file template.tex

