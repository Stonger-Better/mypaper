%%%%%%%%%%%%%%%%%%%%%%% file template.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is a general template file for the LaTeX package SVJour3
% for Springer journals.          Springer Heidelberg 2010/09/16
%
% Copy it to a new file with a new name and use it as the basis
% for your article. Delete % signs as needed.
%
% This template includes a few options for different layouts and
% content for various journals. Please consult a previous issue of
% your journal as needed.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% First comes an example EPS file -- just ignore it and
% proceed on the \documentclass line
% your LaTeX will extract the file if required
\begin{filecontents*}{example.eps}
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 19 19 221 221
%%CreationDate: Mon Sep 29 1997
%%Creator: programmed by hand (JK)
%%EndComments
gsave
newpath
  20 20 moveto
  20 220 lineto
  220 220 lineto
  220 20 lineto
closepath
2 setlinewidth
gsave
  .4 setgray fill
grestore
stroke
grestore
\end{filecontents*}
%
\RequirePackage{fix-cm}
%
%\documentclass{svjour3}                     % onecolumn (standard format)
%\documentclass[smallcondensed]{svjour3}     % onecolumn (ditto)
\documentclass[smallextended]{svjour3}       % onecolumn (second format)
%\documentclass[twocolumn]{svjour3}          % twocolumn
%
\smartqed  % flush right qed marks, e.g. at end of proof
%
\usepackage{graphicx}
\usepackage{amssymb,amsmath}
\usepackage{array,tabularx,multirow}
\usepackage[linesnumbered,boxed]{algorithm2e}
%\usepackage{algorithm}
%\usepackage{algorithmic}
% \usepackage{mathptmx}      % use Times fonts if available on your TeX system
%
% insert here the call for the packages your document requires
%\usepackage{latexsym}
% etc.
%
% please place your own definitions here and don't use \def but
% \newcommand{}{}

%\newtheorem{lemma}{\bf{Lemma}}[section]

%\newtheorem{theorem}{\bf{Theorem}}[section]

%\newtheorem{definition}{Definition}[section]
% Insert the name of "your journal" with
% \journalname{myjournal}

\begin{document}

\title{A Preconditioning Algorithm for Large Linear Systems Based on A Low-stretch Spanning Tree% Based on a Low-stretch Spanning Tree  %\thanks{Grants or other notes
%about the article that should go on the front page should be
%placed here. General acknowledgments should be placed at the end of the article.}
%A practical preconditioning algorithm for Laplacian(SDD) linear system
}
%\subtitle{Do you have a subtitle?\\ If so, write it here}

%\titlerunning{Short form of title}        % if too long for running head

\author{Huirong Zhang \and  Jianwen Cao \and Xiaohui Liu  %etc.
}%\inst{1,2}

%\authorrunning{Short form of author list} % if too long for running head

\institute{H.R. Zhang \at
              State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences. \\
              \email{zhang06.happy@163.com}           %  \\
%%             \emph{Present address:} of F. Author  %  if needed
           \and
           J.W. Cao \at
             State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences.\\
           \and
           X.H. Liu  \at
              State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences.\\
}

%\institute{  State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences. \\
%              \email{zhang06.happy@163.com}           %  \\
%%             \emph{Present address:} of F. Author  %  if needed
%           \and
%             State Key Laboratory of Computer Science, Institute of Software Chinese Academy of Sciences.\\
%          }


\date{Received: date / Accepted: date}
% The correct dates will be entered by the editor


\maketitle

\begin{abstract}
In this paper, we present an efficient algorithm for preconditioning sparse, symmetric, diagonally-dominant(SDD) linear systems by using combinatorial preconditioning techniques.  Firstly, we build a low-stretch spanning tree of a graph associated with a linear system by using algorithm proposed by Alon et al. and  add appropriate high stretch edges to the tree straightly or add edges based on a tree-decomposition algorithm to get an optimized subgraph. Then, convert the subgraph into a SDD matrix and take it as a preconditioner. %solve a  SDD system $Ax=b$ preconditioned by a matrix converted from the subgraph we create.
Finally, we give an implementation and  performance analysis of our subgraph preconditioners. %We show experimentally that these combinatorial preconditioners  have robust convergence and  have good scalability.
We test the algorithm on extensive numerical experiments arising from both elliptic PDEs and  Laplacian systems of network graphs. Numerical experiments show that preconditioners constructed by our algorithm are more efficient than incomplete Choleskey factorization preconditioners and Vaidya's preconditioners. Moreover, our preconditioning algorithm is insensitive to the boundary condition and it scales well. %, which means our combinatorial preconditioning algorithm has good scalability.
%In addition, for the 2-D problems considered in this paper, preconditioners obtained based on a low stretch tree have better performance than  incomplete
%Cholesky preconditioners, which is sensitive to boundary  and anisotropy.
  Besides, the efficiency of our subgraphs preconditioners depends on not only the stretch  but also depends on the sparsity.  %But they are % and matrix size.


%\noindent {\bf AMS subject classifications: }
\keywords{preconditioning algorithm \and linear systems  \and low-stretch spanning tree \and tree-decomposition \and experimental analysis}
%\keywords{PCG Algorithm;  Augmented low stretch spanning tree; Tree-decomposition; SDD linear systems}
% \PACS{PACS code1 \and PACS code2 \and more}
% \subclass{MSC code1 \and MSC code2 \and more}
\end{abstract}

%Moreover, the smallest generalized eigenvalues of a linear system preconditioned by a subgraph preconditioner is 1, just as analyzed in theory.
%The experiments on network graphs show that  when a spanning tree of the underlying graph of a matrix has  low  average stretch, %or small max stretch at the same time,
%a preconditioner constructed based on such a spanning tree applied with a CG solver converges fast.






\section{An augmented low stretch spanning tree preconditioning algorithm}\label{sec:3}

In this section, we propose a subgraph preconditioning algorithm based on a low stretch spanning tree by constructing a subgraph. We give two schemes to construct a subgraph by adding appropriate edges to a tree. One  intuitive scheme is to add edges with high stretch  to the tree straightly. Another scheme is to
 take advantage of the tree decomposition algorithm introduced in \cite{BHT}, and to add off-tree edges between the subtrees after the decomposition which have high stretch. With both two schemes, one can get a stretch optimized subgraph according to the combinatorial bounds on subgraph preconditioners.

We firstly give our two algorithms named \textbf{Sub$\_$Add}  and \textbf{Sub$\_$Decomp}  corresponding to the  two schemes as above. Then introduce the AKPW algorithm \cite{AKPW} for building a low stretch spanning tree.
Finally, complete our augmented low stretch spanning tree preconditioning algorithm.




\subsection{Build a subgraph based on a low stretch  spanning tree}
% Property P1 and P2 in Theorem \ref{main} inspire us,
 %we can build a subgraph based on a low stretch tree by decreasing max stretch or total stretch.

From Theorem \ref{product} and Theorem \ref{basic}, we know the stretch of a subgraph is a bound on the $\| W\|_2^2$, where $W$ can be defined by using an incident factorization. We have an intuitive interpretation of $W$ that columns of $W$ in fact act as the combination coefficients of edges vector in $U$ when choose the columns of  $V$ as a basis of $span(U)$. If we add edges who have large combination coefficients to $T$, namely, augment columns of $V$, the combination coefficients of these added edges decrease to 1. %A algebraic description is as below.
%Let $A$, $B$  be  Laplacian matrices with underlying graphs $G$, $T$ respectively, where $T$ is a spanning tree of $G$. $A,B$ have incident factorization $A=UU^T$, $B=VV^T$ in form of (\ref{incident}).
%Obviously, columns of $V$ consist of  edge vectors corresponding to tree edges in  $T$, columns of $U$ consist of edge vectors  corresponding to edges in  $G$  including tree edges and non-tree edges. Split columns of $U$ into two parts $U=(U_T, U_N)$, where $U_T$ consist of tree edge vectors and $U_N$  consist of non-tree edge vectors.
%Denote $W$ be the matrix defined as Theorem \ref{basic}, satisfying $U=VW$.  We can split columns of $W$ according to $U$
%into $W=(W_T,W_N)$. Specifically, $U_T=VW_T$, $U_N=VW_N$, with $W_T=(I,0)^T$ when permute column of $U_T$ properly.
%Now we continue to split $W_N$ into $W_N=(W_{N_1},W_{N_2})$, where $W_{N_1}$ corresponding to the  edges with high stretch.
%If we add these  edges with high stretch to tree $T$, $V$ is augmented to be $V'=(V,V_{N_1})$ with $V_{N_1}$ consisting of added edges vectors. In this way, let $U=V'W$,  $W_N=(W_{N_1},W_{N_2})$, where $W_{N_1}=(I,0)^T$ when permute columns of $W_{N_1}$ properly, the $F-$norm of $W$ decrease by at least $\| W_{N_1}\|_F^2$.
 According to the definition of stretch and $W$ we know if the total stretch of the added edges is large, the improvement on $\| W\|_F$ is  notable. According to Theorem \ref{main}, we know adding high stretch edge can make the eigenvalues of the preconditioned system more clustered.
Now we give two following algorithms to build such a subgraph based on a low stretch  spanning tree. The first algorithm \textbf{Sub$\_$Add} is to add off-tree edges with highest stretch  to the tree straightly. The second algorithm \textbf{Sub$\_$Decomp} is to add off-tree edges with high stretch by using a tree decomposition algorithm given by Chen et al. in \cite{BHT}.




\SetKwFunction{KwFn}{Sub$\_$Add}
\begin{algorithm}[ht]
%\TitleOfAlgo{title($G,T,k$)}
$H=$\KwFn{$G,T,k$}
\caption{Building subgraph algorithm by adding edges straightly}\label{sub_add}
\KwIn{$G=(V,E,l)$ is a graph\;
 $T=(V,F,l)$ is a low stretch spanning tree of $G$\;
  $k$ is the number of edges to add.}
\KwOut{$H$ is the subgraph for preconditioning}
%For all $e_i\in E$, set s(i)
Set $L=\emptyset$\;
\For{$e_i\in E$}
  {Calculate $s(i)=stretch(e_i)$\;
  }

 S=Sort($s$,descend)\;

\For{$i=1,\cdots,k$}
  {% $s(i)=stretch(e_i)$\;
  \If{ $S(i)=s(j_i)$}
   {$L=L\cup\{e_{j_i}\}$\;
   }
  }
$H=T\bigcup L$\;

return $H$\;
\end{algorithm}



\SetKwFunction{KwFn}{Sub$\_$Decomp}
\begin{algorithm}[ht]
$H=$\KwFn{$G,T,t$}
\caption{Building subgraph algorithm by using tree-decomposition}\label{sub_decom}
\KwIn{$G=(V,E,l)$ is the graph, $T=(V,F,l)$ is the low stretch spanning tree of $G$, $t$ is the number of subtrees planing to decompose.}
\KwOut{$H$ is the subgraph for preconditioning}

\For{$e\in E$}
  {Calculate $stretch(e)$\;
  }
  ($\rho,T_0,\cdots,T_k$)= \textbf{Tree$\_$Partition} $(T,root,t)$\;
 Set $L=\emptyset$\;

 \For{all subtree pairs $\{T_i,T_j\}$}
{
 \If{there exists an edge $e\in T$, $\rho(e)=\{T_i,T_j\}$ }
  {
   just connect $T_i,T_j$ with $e$\;
  }
 \Else
 {
  choose one edge $e'$ who has the max stretch from all the edges that connect subtrees $\{T_i,T_j\}$\;
  $L=L\cup\{e'\}$\;
 }

}

$H=T\bigcup L$\;

return $H$\;
\end{algorithm}

The subroutine Tree$\_$Partition  in \textbf{Sub$\_$Decomp} is to decompose the spanning tree into connected subtrees, the size of each subtree is between $n/t$ and $(d(n+1)/t)+1$, where $d$ is the maximum degree of vertices for some constant $d$.
The details
of the partitioning is given in \cite{BHT}.



\subsection{AKPW algorithm for building a low stretch spanning tree}
Algorithm \ref{akpw_all} is an algorithm for building a low stretch spanning tree proposed by \cite{AKPW}. It iteratively use a partition procedure to decompose a graph into low radii clusters with a small cut size. There are mainly two parameters $x,y$ in Algorithm \ref{akpw_all}, we will explain later. %We introduce this algorithm by explaining three subroutines in it.


\SetKwFunction{KwFn}{AKPW}
\begin{algorithm}[ht]
%\TitleOfAlgo{title($G,T,k$)}
$T=$\KwFn{$G,x,y$}
\caption{building a low stretch spanning tree algorithm }\label{akpw_all}
\KwIn{$G=(V,E,l)$ is the graph\;
 $T=(V,F,l)$ is the low stretch spanning tree of $G$.}
\KwOut{$T$ is low stretch spanning tree}
%For all $e_i\in E$, set s(i)
Set $j=1$ and $G_j=G$, $T=\emptyset$\;
Set $x,y$, normalized all edge length to be no less than 1,break the edges multiset $E$ into subclasses $E_i$, for $i\geq 1$, according to edge length, $E_i=\{e|\,l(e)\in[y^{i-1},y^i)\}$\;
\While{$\bigcup_i E_i\neq \emptyset$}
{
\begin{itemize}
  \item[a.] $\{C_1,\cdots,C_k\}$=\textbf{Partition}($G_j,j,x,y,\rho$);
  \item [b.]\For {$i=1,\cdots,k$}
 { $T_i=\textbf{SPT}(C_i)$\;}
  \item [c.]$T=T\bigcup T_i$;
  \item [d.]$G_{j+1}$ = \textbf{Contract}($G_j,\{C_1,\cdots,C_k\}$)\;

  \item [e.]Set $j=j+1$.
\end{itemize}
}

return $T$\;
\end{algorithm}

The subroutine \textbf{Partition} is a main procedure in Algorithm \ref{akpw_all} which is a variant of
the clustering algorithm of Awerbuch \cite{Aw}. This subroutine partition is the given graph into clusters with low radii (specifically, $y(n)=O(xlogn)$), where $x$ is a parameter depending on $n$ ($n=|V|$), and ensure most of the edges are internal edges of the clusters, only a fraction of $1/x(n)$ of the edges are inter-cluster edges (endpoints in different clusters). %Algorithm \ref{partition} is a crude frame of this subroutine (for a weighted graph).
%For the unweighted case, the partition is some simpler than weighted, we don't list here.

The subroutine \textbf{Contract} in Algorithm \ref{akpw_all}  is to contract every cluster $C_i$ into a supervertex $v_{C_i}$, take every inter-cluster edge $e=(u,w)\in E$ ($u\in C_i$) $w\in C_j$ as a superedge $\widehat{e}=(v_{C_i},v_{C_j})$.
%\newpage
The subroutine \textbf{SPT} in Algorithm \ref{akpw_all}  is to find a shortest path spanning tree for every cluster.

 Details for subroutines \textbf{Partition}, \textbf{Contract} and \textbf{SPT} can be found in \cite{AKPW,Aw}
%The last two subroutines are trivial, we omit the details here.
The stretch of a spanning tree constructed by Algorithm \ref{akpw_all} is $O(m 2^{\sqrt{logn log\,logn}} )$.
%\SetKwFunction{KwFn}{Partition}
%\begin{algorithm}[ht]
%%\TitleOfAlgo{title($G,T,k$)}
%$\{C_1,\cdots,C_k\}$=\KwFn{$G_j,j,x,y,\rho$}\;
%\caption{partition a graph into clusters}\label{partition}
%\KwIn{$G=(V,E,l)$ is the graph\;
% $y$ is the radius bound of every cluster, $x$ is the fraction of inter-cluster edges.}
%\KwOut{$\{C_1,\cdots,C_k\}$ are the clusters after partitioning.}
%Set $i$=1;
%%For all $e_i\in E$, set s(i)
%Active edges class $E_j$ and feed it into $G_j$\;
% choose random root vertex $v$ in $G_j$, take $v$ as a center to grow a ball $C_i$ by traversing neighbours layer by layer along all active edges in $\{E_{j-\rho+1},\cdots,E_j\}$  until $|\partial(C_i)|\leq \frac{|E|}{x}$, $G_j=G_j\backslash C_1$\;
%Set $i=i+1$, repeat the above step to find cluster $C_i$, until all vertices are assigned to clusters\;
%
%return $\{C_1,\cdots,C_k\}$\;
%\end{algorithm}
%
%
%??????????%%%%%%%%%%此处算法名称都没有改

\subsection{Our preconditioning algorithm }

Now we construct our subgraph preconditioners for a positive definite SDD matrix $A\in \mathbb{R}^{n\times n}$. Suppose $A$ is sparse with  $m=O(n)$ nonzero entries.
For simplicity, assume matrix $A$ a is Laplacian matrix.
 If not, we can use Gremban's reduction  to convert it into one with non-negative off diagonals or split the matrix into a Laplacian matrix plus a non-negative diagonal matrix. We just need to consider constructing a preconditioner for the Laplacian matrix. Our complete  preconditioning algorithm is as follows (Algorithm \ref{com_pre}).


\SetKwFunction{KwFn}{Precon$\_$Create}
\begin{algorithm}[ht]
%\TitleOfAlgo{title($G,T,k$)}
  $B$= \KwFn{$A,t$}\;
\caption{Augmented low stretch spanning tree precontioner for a SDD matrix}\label{com_pre}
\KwIn{$A$ is a Laplacian matrix\;
%\KwIn{$A$ is a SDD matrix\;
  $t$ is the edges to add or the number of subtrees to decompose.}
\KwOut{B is a preconditioner of $A$}
\If{all off diagonals in $A$ are equal.}
{construct an undirected unweighted graph $G=(V,E)$ corresponding to $A$\; }
\Else
{construct an undirected weighted graph $G=(V,E,\omega)$ corresponding to  $A$, assign length to every edge $l:E\rightarrow R^{+}$.\;}
set parameters  for Algorithm \ref{akpw_all}\;
construct a low stretch spanning tree $T=AKPW(G,x,y,\rho)$\;
$H=$\textbf{Sub$\_$Add($G,T,t$)} or $H=$\textbf{Sub$\_$Decomp($G,T,t$)}\;%call \textbf{Sub$\_$Add} or \textbf{Sub$\_$Decomp};
construct a Laplacian matrix $B$ corresponding to $H$.
return $B$\;
\end{algorithm}




Now we analyze the preconditioner we construct by using  Algorithm \ref{com_pre}.
%%%%%%%%%%%%%%%%% 春风师姐说，最重要的定理，纠结的问题是需不需要改名字

 \begin{theorem}\label{th5}
Let $A\in \mathbb{R}^{n\times n}$ be a positive definite SDD matrix with $m$ non-zeros. Denote $G=(V,E)$ be the underlying graph  corresponding to $A$, $T$ be the spanning tree, $H$ be subgraph constructed in Algorithm \ref{com_pre}, and $B$ be the peconditioner of $A$ which is output of Algorithm \ref{com_pre}. Let $N$ be the set of edges added to $T$, then

\begin{equation}\label{fix_stretch}
  1\leq \lambda_i\leq stretch(E)-stretch(N)\quad 1\leq i\leq n,
\end{equation}
where $ \lambda_i$ are generalized eigenvalues of $(A,B)$.
Moreover, according to the property P2 in Theorem \ref{main}, we have another tighter combinatorial bound on generalized eigenvalues as follows,

\begin{equation}\label{tight}
  1\leq \lambda_i\leq \tau( d(((d+1)n/t) + 1),
\end{equation}
where  $\tau=\max_{e\in G}stretch(e)$.
\end{theorem}


\begin{proof}


By using Theorem \ref{product},  $A,B$ have incident factorization $A=UU^T$, $B=VV^T$ in form of (\ref{incident}). Then define $W$ according to Theorem \ref{basic}, satisfying $U=VW$.

Split columns of $U$ into two part $U=(U_T, U_N)$, where $U_T$ consist of tree edge vectors and $U_N$  consist of non-tree edge vectors and  split columns of $W$ according to $U$
into $W=(W_T,W_N)$. Specifically, $U_T=VW_T$, $U_N=VW_N$, with $W_T=(I,0)^T$ when permute column of $U_T$ properly.
Now we continue split $W_N$ into $W_N=(W_{N_1},W_{N_2})$, where $W_{N_1}$ corresponding to the  edges added to $T$ in Algorithm \ref{com_pre}.
 $V$ is augmented to be $V'=(V,V_{N_1})$ with $V_{N_1}$ consisting of added edges vectors. In this way, let $U=V'W'$,  $W'=(W'_T,W'_N)$, $W'_N=(W'_{N_1},W'_{N_2})$, where $W'_{N_1}=(I,0)^T$ when permute columns of $W'_{N_1}$ properly,


Then $W'$ can be written as $\left(
                            \begin{array}{cc}
                              I & 0 \\
                              0 & W'_{N_2} \\
                            \end{array}
                          \right)$

It's apparent that $\| W'_{N_2}\|_F^2\leq \| W_{N_2}\|_F^2$ as every edge in $G$ are supported by fewer edges of $H$ than that of $T$.

So, we have
\begin{align*}
 \| W'\|_2^2  & \leq \| W'_{N_2}\|_2^2  \leq \| W'_{N_2}\|_F^2 \leq \| W_{N_2}\|_F^2\\
   & = stretch(E)-stretch(N)-n+1\\
   &\leq stretch(E)-stretch(N).
\end{align*}

Now we prove inequality (\ref{tight}).
Just as the analysis in \cite{support}, an edge $e\in H$ supports at most $d(((d+1)n/t)+1)$ edges.  If endpoints of $e$ are in a single subgraph, it just support edges in this subgraph.  If endpoints of $e$  are in two distinct subgraphs, $e$ support only edges with at least one endpoint in  one of the subgraphs.
There are at most $d(((d+1)n/t) + 1$ edges incident
to vertices in a subgraph, hence the bound.

According to the property P2 in Theorem \ref{main}, inequality (\ref{tight}) is apparent.
\end{proof}



\end{document}
% end of file template.tex

